package empires.release;

import lmu.utils.EnumGetter;
import lmu.utils.ObjectGetter;

import java.util.Arrays;


public class EmpiReS {
    public static enum EmpiReTask {
        ECMMAPPER("ecmapper"),
        BUILDINDEX("buildindex"),
        EQCFROMBAMS("ecfrombams"),
        DIFFEXPONEXPRSET("diffexp_on_eset"),
        EQCINPUT("diffexp_diffsplic_on_eccounts"),
        GENERATEREADS("generatereads"),
        SIMULATECOUNTS("simulatecounts"),
        UNKNOWN("unknown");

        String label;

        private EmpiReTask(String var3) {
            this.label = var3;
            EnumGetter.add(var3, this);
        }

        public static EmpiReS.EmpiReTask get(String var0) {
            return ObjectGetter.map(values(), (var0x) -> {
                return var0x.label;
            }).contains(var0) ? (EmpiReS.EmpiReTask)EnumGetter.get(var0, true) : UNKNOWN;
        }
    }

    public static void main(String[] var0) {
        String var1 = "Please provide a task as first parameter. The following tasks are available:\n\tbuildindex - build the genome index for the equivalence class variant of contextmap\n\tecmapper - mapping of fastq files to equivalence classes\n\tecfrombams - derive equivalence class counts from mapped reads (BAM files)\n\tdiffexp_on_eset - analyse differential expression from expression set like formatted data\n\tdiffexp_diffsplic_on_eccounts - analyse differential expression and differential alternative splicing from equivalence class counts derived from ecmapper or ecfrombams\n\tsimulatecounts - simulate counts for a benchmarking dataset based on measured data with many replicates\n\tgeneratereads - generate reads for the simulated counts for a benchmarking dataset\n";
        if (var0.length == 0) {
            System.err.printf(var1);
        } else {
            boolean var2 = false;

            for (int var3 = 0; var3 < var0.length; ++var3) {
                if (var0[var3].equals("-h") || var0[var3].equals("--help")) {
                    var2 = true;
                }
            }

            String[] var4 = (String[]) Arrays.copyOfRange(var0, 1, var0.length);
            switch (EmpiReS.EmpiReTask.get(var0[0])) {
                case ECMMAPPER:
                    if (var2) {
                        System.err.print("Use the equivalence class variant of contextmap to map reads\n\nThis task needs the following inputs:\n\t-index: binary index build for the given genome/annotation by the buildindex task\n\t-table: tsv file containing for each sample that should be mapped one line. It needs to contain at least the columns:\n\t\tlabel: name of the sample\n\t\tcondition: condition of the sample, replicate measurements share the same value in this column\n\t\tfw: path to the forward strand fastq file\n\t\tstrandness:  a value of \"true\" indicates that the first read defines the strandness, while a value of \"false\" indicates that the second read defines the strandness and an empty string indicates that the measurement was strand unspecific.\n\t\toptional: rw: path to the reverse strand fastq file in case of a paired-end sequencing experiment.\n\t-o path to the output count table\n\t optional: -nthreads: number of parallel threads used - default 10\n\toptional: -basedir: path to a directory, if given the paths given in the sample table are relative to this directory\n");
                        return;
                    }

                    ECMMapper.main(var4);
                    return;
                case BUILDINDEX:
                    if (var2) {
                        System.err.print("Builds the index for a given genome and its annotation for the equivalence class variant of contextmap.\n\nThis task needs the following inputs:\n\t-gtf genome annotation in GTF format\n\t-genome genome sequences as fasta file\n\t-genomeidx index of the genome fasta file, e.g. generated by samtools faidx\n\t-o path to the binary output file\n");
                        return;
                    }

                    BuildECMMapperIndex.main(var4);
                    return;
                case EQCFROMBAMS:
                    if (var2) {
                        System.err.print("Counts the number of reads per equivalence class for mapped reads.\n\nThis task needs the following inputs:\n\t-gtf genome annoataion in GTF format\n\t-table table containing for each sample one line. It needs to contain at least the columns:\n\t\tlabel: label of the sample\n\t\tbam: path to the BAM file containins the mapped reads for this sample\n\t\tstrandness: a value of \"true\" indicates that the first read defines the strandness, while a value of \"false\" indicates that the second read defines the strandness and an empty string indicates that the measurement was strand unspecific.\n-o path to the output table containing the counts for the equivalence classes.\noptional: -basedir: path to a directory, if given the paths given in the sample table are relative to this directory\n");
                        return;
                    }

                    DeriveEQCCountsFromBams.main(var4);
                    return;
                case DIFFEXPONEXPRSET:
                    if (var2) {
                        System.err.print("Analyses differential expression by EmpiReS using the expression set input.\n\nThis task needs the following inputs:\n\t-inputdir path to directory that contains the exprs.txt, p_data.txt and f_data.txt files. For details on the file formats of these files see the README or vignette.\n\t-o path to the output table\n\toptional: -cond1 and -cond2 conditions from f_data.txt that for which the analysis should be done.\n");
                        return;
                    }

                    DiffExpOnExpressionSet.main(var4);
                    return;
                case EQCINPUT:
                    if (var2) {
                        System.err.print("Analyses both differential expression and differnetial alternative splicing for a table of equivalence counts.\n\nThis task needs the following inputs:\n\t-i input table of equivalence class read counts generated by ecfrombams or ecmapper tasks\n\t-samples a tsv file containing for each sample one line. It needs to contain at least the columns label (name of the sample) and condition (replicates share the same condition value).\n\t-o path to the output tsv\n\toptional: -cond1 and -cond2 conditions from the sample table for which the analysis should be done. By default the first two conditions from the sample table are used.\n");
                        return;
                    }

                    EQCInput.main(var4);
                    return;
                case GENERATEREADS:
                    if (var2) {
                        System.err.print("Generates reads from the simulated counts generated by the simulatecounts task.\n\nThis task needs the following inputs:\n\t-gtf genome annotation in GTF format\n\t-genome genome sequence in fasta format\n\t-genomeidx index of genome fasta, e.g. generated by samtools faidx\n\t-trcounts simulated transcript counts generated by the simulatecounts task\n\t-od path to the output directory\n\toptional: -nobams omits the output of the ideal mapping BAM files\n\toptional: -mutrate mutation rate of the reads\n\toptional: -readlength read length\n\toptional: -fraglengthmean mean of the normal distribution from which fragment lengths are generated\n\toptional: -fraglengthsd standard deviation of the normal distribution from which fragment lengths are generated\n\t-biaspos path to a file containing the position-wise biases derived from experimental yeast data. For details on the file format see the example file or the vignette.\n");
                        return;
                    }

                    GenerateReads.main(var4);
                    return;
                case SIMULATECOUNTS:
                    if (var2) {
                        System.err.print("Simulates counts for benchmarking of differential expression and differential alternative splicing methods.\n\nThis task needs the following inputs:\n\t-incounts table containing gene level read counts for many replicates used as input for the simulation. For details on the format see the example files or the vignette.\n\t-transcriptsToSimulate list of transcripts that should be simulated (both differential and unchanged)\n\t-gtf genome annotation in GTF format\n\t-diffexp list of gene ids whose transcripts should be simulated to be differentially expressed\n\t-diffsplic list of geneids whose transcripts should be differentially alternatively spliced in the simulated data. The list of transcripts provided to -transcriptsToSimulate should contain 2 transcripts for these gene ids.\n\t-od path to output directory.\n");
                        return;
                    }

                    GenerateSimulatedTrCounts.main(var4);
                    return;
                default:
                    System.err.printf(var1);
            }
        }
    }
}
